<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>webpack</title>

		<meta name="description" content="webpack ">
		<meta name="author" content="geyulong">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		<style>
			.config pre {
				width: 100%;
				margin-top: 0px;
			}
			.config pre code {
				font-size: 18px;
				max-height: 650px;
			}	
		</style>

        

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>webpack</h1>
					<h3>module bundler </h3>
					<p>
						<small>Created by <a href="https://github.com/geyulong">geyulong</a> / <a href="mailto:gaiyulong@gmail.com">@geyulong</a></small>
					</p>
				</section>
				<section data-markdown="" style="text-align: justify;font-size: 24px;">
					现今的web，都很丰富，它们拥有着复杂的JavaScript代码，一大堆依赖包，为了简化开发的复杂度，前端世界出现了很多很好的实践方法。

- 模块化
- sass,less等预处理器
- jsx，jade的模板
- 类似于TypeScript这种在JavaScript基础上拓展的开发语言
- ...

这些改进确实大大提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别，而手动处理是非常繁琐的，webpack应运而生！

				</section>

				<section>
					<h3>什么是webpack</h2>
					<p style="text-align: justify;font-size: 28px;">
模块打包机：它做的事情就是，分析你的项目结构，找到javascript模块，以及其它的一些浏览器不能直接运行的拓展语言(less,sass,jsx),并将其打包为合适的格式，供浏览器使用。
					</p>
					<p style="text-align: justify;font-size: 28px;">
						web开发中常用到的静态资源，主要是js,css,img, jade,等文件，webpack中，将静态资源文件称为模块。其可以兼容多种js书写规范(cmd,amd等规范)，且可以处理模块间的依赖关系，具有更强大的js模块化的功能。
					</p>
				</section>
				<section>
					<img data-src="img/webpack.png" alt="webpack" />
				</section>
				<section>
					<div style="float: left;width:50%;">
						<img data-src="img/webpack.png" alt="webpack" />
					</div>
					<div style="float: left;width: 50%;font-size: 28px;text-align: justify;padding-top: 10px;">
						当webpack处理程序时，它会递归的构建一个依赖关系图标，其中包含程序所需的每个模块，然后将所有这些模块打包成少量的bundle，由浏览器加载。

					</div>
				</section>
				<section>
					<section>
						<h3>Grunt/Gulp</h3>
						<p>前端构建工具</p>
					</section>
					<section>
						<p>与webpack不是一回事</p>
					</section>
					<section style="text-align: justify;">
						<p>grunt是来优化前端工作流程。比如自动刷新页面，压缩等,配置你需要的插件，把以前需要手工做的事情，让它帮你做了。</p>
					</section>
					<section>
						<p>webpack & grunt/gulp 配合使用</p>
						<p> npm i gulp-webpack</p>
					</section>
					<section data-markdown="">
						- gulp: 处理html压缩/预处理/条件编译，压缩图片，精灵图自动合并等任务
						- webpack: 管理模块化，构建js/css
					</section>
					<section data-markdown="">
						- webpack & browserify

						- seajs & requirejs
					</section>
					<section>
						<p>seajs/require</p>	
						<p style="text-align:justify;font-size: 28px;">
						是一种在线"编译" 模块的方案，相当于在页面上加载一个 CMD/AMD 解释器。这样浏览器就认识了 define、exports、module 这些东西。也就实现了模块化。
						</p>
					</section>
					<section>
						<p>browserify/webpack</p>
						<p style="text-align: justify;font-size: 28px;">
						是一个预编译模块的方案，相比于上面 ，这个方案更加智能。没用过browserify，这里以webpack为例。首先，它是预编译的，不需要在浏览器中加载解释器。另外，你在本地直接写JS，不管是 AMD / CMD / ES6 风格的模块化，它都能认识，并且编译成浏览器认识的JS。
						</p>
					</section>


				</section>
				<section>
					<h3> welcome to webpack!</h3>
				</section>
				<section>
					<section>
						<h3> 安装</h3>
					</section>
					<section style="text-align: justify;">
						webpack是一个基于node的项目，所以安装之前要确保node 和 npm 是否已准备好.
					</section>
					<section data-markdown="">
						 - npm install --save-dev webpack//本地
						 - npm install --save-dev webpack@version
						 - npm install --g webpack //全局
					</section>

				</section>
				<section>
					<section>
						<h3> 使用</h3>
					</section>
					<section data-markdown="">
						- 终端命令行使用
						- 配置文件使用
					</section>
					<section data-markdown="">
						<h2>终端命令行使用</h2>
						```js
							webpack entry.js result.js
							//其中entry.js是入口文件，result.js是打包后的输出文件
						```
						如果在终端中进行复杂的操作，还是不太方便且容易出错的.
					</section>
					<section>
						<img data-src="img/root.png"/>	
						<img data-src="img/cli1.png"/>
						<img data-src="img/build1.png" />
					</section>
					<section>
						<img data-src="img/root.png" />
						<img data-src="img/cli2.png" />	
						<img data-src="img/build2.png" />
					</section>
					<section data-markdown="">
						```js
							webpack --help / -h
						```
					</section>
					<section data-markdown="">
						#### 使用配置文件		
					</section>
					<section data-markdown="" style="text-align: justify;">
						配置文件默认为webpack.config.js	
						```js
							webpack //默认执行webpack.config.js
						```
						如果你想使用其他配置文件，可以用--config参数
						```js
							webpack --config example.config.js	
						```
					</section>

					<section data-markdown="">
					- 更快的执行打包任务
						npm可以引导任务执行,对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。
						```json
							//package.json
							"scripts": {
								"start": "webpack" //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令
							 },
						```
					</section>
					<section data-markdown="" style="font-size: 24px;">
						常用的命令：

						- webpack 最基本的启动webpack命令
						- webpack --config XXX.js //使用另一份配置文件(比如webpack.config2.js)来打包
						- webpack --env.production  //指定构造环境，传入webpack配置文件中使用的环境变量。
						- webpack --colors 输出结果带彩色，比如: 用红色显示耗时较长的步骤
						- webpack --profile 输出性能数据，可以看到每一步的耗时
						- webpack --display-modules 默认情况下node_modules下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块
						- webpack --output-x //输出配置
						- webpack --debug
						- webpack --devtool
						- webpack --progress
						- webpack --module-x //模块配置
						- webpack --watch 
						- webpack --optimize-x 性能优化配置
						- webpack --resolve 
						- webpack 统计数据
						- 高级配置

					</section>

				</section>
				<section >
					<section data-markdown="">
						Webpack.config.js	
					</section>			
					<section data-markdown="" class="config">
					```js
						module.exports = {
							entry: "./app/entry", //string | object | array 应用开始执行，webpack开始打包
							output: {
								path: path.resolve(__dirname, "dist"), //string
								filename: 'bundle.js',
								publickPath: "",
								library: '',
								library: 'umd',
								...
							},
							module: { //模块配置
								rules: [
									//模块规则【配置loader,解析器等选项
								]
							},
							resolve: { //解析模块请求的选项
								modules: [],
								extensions: ['', '.js', '.json', '.scss'],
								alias: {
									AppStore: 'js/stores/AppStores.js',
									...
								}
							},
							devtool: "source-map",
							context: "",
							target: "",
							externals: [],
							devServer: [],
							plugins: [],
							performance: {},
							...
						}
					```
	
					</section>
					<section data-markdown="">
						我们先理解四个核心概念
						- entry
						- output
						- loader
						- plugins
					</section>
					<section data-markdown="" style="text-align: justify;font-size: 24px;">
						- entry

						webpack 将创建所有应用程序的依赖关系图表(dependency graph).图表的起点被称为入口起点(entry point).入口起点告诉webpack从哪里开始，并遵循着依赖关系图表知道要打包什么。可以认为是app的第一个启动文件。
						```js
							module.exports = {
								entry: './path/to/my/entry/file.js'
							}
						```
					</section>
					<section data-markdown="" style="text-align: justify;font-size: 22px;">
						- output

						将所有的资源归拢在一起后，还需要告诉webpack在哪里打包应用程序，就是如何处理归拢在一起的代码。
						
						```js
							const path = require('path');

							module.exports = {
							  entry: './path/to/my/entry/file.js',
							  output: {
								path: path.resolve(__dirname, 'dist'),
								filename: 'my-first-webpack.bundle.js'
							  }
							};
						```
					</section>
					<section data-markdown="" style="text-align: justify;font-size: 22px;">
							- loader
							鼎鼎大名的loaders登场了!

							Loaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。
					</section>

					<section data-markdown="" style="text-align: justify;font-size: 28px;">

							```js
								module.exports = {
									entry: './path/to/my/entry/file.js'
									output: {
										path: path.resolve(__dirname, 'dist'),
										filename: 'my-first-webpack.bundle.js'
									},
									module: {
										rules: [
											{
												test: /\.js$/,
												exclude: /node_modules/,
												loader: "babel-loader",
												options: {
													presets: [
														["es2015", {"modules": false}],
														"stage-0",
														"react"
													],
													plugins: [
														"transform-async-to-generator",
														"transform-decorators-legacy"
													]
												}
											},
										]
									}
								}
							```
						
							</section>
							<section data-markdown="" style="text-align: justify;font-size: 28px;">
							以上配置中，对一个单独的module对象定义了rules属性，里边包含两个必须属性：test 和 loader.
							- test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须）
							- loader: loaders的别名(新版)：loader的名称（必须）
							- include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；
							- options: 为loaders提供额外的设置选项（可选)


							> “嘿，webpack compiler，当你碰到「在 require()/import 语句中被解析为 '.js' 或 '.jsx' 的路径」时，在你把它们添加并打包之前，要先使用 babel-loader 去转换”。
					</section>
					<section data-markdown="" style="text-align: justify;font-size: 22px;">
						- plugins	

						插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。
						Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。

Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。

						想要一个插件，你只需要require它，然后把它天骄到plugins数组中，多数插件可以通过选项option自定义。也可以在一个配置文件中因不同目的而多次使用同一个插件，你需要用new来创建实例，并调用它。

						```js
							const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm
							const webpack = require('webpack'); //to access built-in plugins
							const path = require('path');

							const config = {
							  entry: './path/to/my/entry/file.js',
							  output: {
								path: path.resolve(__dirname, 'dist'),
								filename: 'my-first-webpack.bundle.js'
							  },
							  module: {
								rules: [
								  {test: /\.(js|jsx)$/, use: 'babel-loader'}
								]
							  },
							  plugins: [
								new webpack.optimize.UglifyJsPlugin(),
								new HtmlWebpackPlugin({template: './src/index.html'})
							  ]
							};

							module.exports = config;
						```

					</section>

						
				</section>

				<section>
					<section data-markdown="">
						### loaders
					</section>
					<section data-markdown="" style="font-size: 20px;text-align: left;">
						文件
						- file-loader:	将文件发送到输出文件夹，并返回(相对)URL
						- url-loader:	同file-loader一样工作， 但如果文件小于限制，可以返回data URL.

						JSON
						- json-loader:	加载JSON文件

						转换编译

						- babel-loader:	加载es6代码，使用babel转义为es5
						- coffee-loader:	像javascript一样加载CoffeeScript
					</section>
					<section data-markdown="" style="font-size: 20px;text-align: left;">
						模板
						- html-loader 导出HTML为字符串，需要引用静态资源
						- jade-loader 
						- markdown-loader 
						- react-markdown-loader

						样式
						- style-loader
						- css-loader
						- less-loader
						- sass-loader
						- postcss-loader
						- stylus-loader

						Linting && Testing (清理和测试)
						- eslint-loader 
						- jshint-loader
						- mocah-loader

						Frameworks 框架
						- vue-loader
					</section>

				</section>

				<section>
					<section data-markdown="">
						### Plugins
					</section>
					<section data-markdown="" style="text-align: justify;font-size: 28px;">
					- 优化插件
						1. OccurenceOrderPlugin :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID
						2. UglifyJsPlugin：压缩JS代码；
						3. ExtractTextPlugin：分离CSS和JS文件

					</section>
					<section data-markdown="" class="config" style="text-align: justify;font-size: 28px;">
					```js
					var webpack = require('webpack');
					var HtmlWebpackPlugin = require('html-webpack-plugin');
					var ExtractTextPlugin = require('extract-text-webpack-plugin');

					module.exports = {
					  entry: __dirname + "/app/main.js",
					  output: {
						path: __dirname + "/build",
						filename: "bundle.js"
					  },

					  module: {
						loaders: [
						  {
							test: /\.json$/,
							loader: "json"
						  },
						  {
							test: /\.js$/,
							exclude: /node_modules/,
							loader: 'babel'
						  },
						  {
							test: /\.css$/,
							loader: ExtractTextPlugin.extract('style', 'css?modules!postcss')
						  }
						]
					  },
					  postcss: [
						require('autoprefixer')
					  ],

					  plugins: [
						new HtmlWebpackPlugin({
						  template: __dirname + "/app/index.tmpl.html"
						}),
						new webpack.optimize.OccurenceOrderPlugin(),
						new webpack.optimize.UglifyJsPlugin(),
						new ExtractTextPlugin("style.css")
					  ]
					}
					```
					</section>
				</section>
				<section >
					<section>
						<h3>强大功能</h3>
					</section>	
					<section data-markdown="" style="text-align: justify;font-size: 28px;">
						###	调试
						开发总是离不开调试，如果方便调试，可以提高开发效率，一般打包的代码不容易识别出错的位置，Source Maps就是来帮我们解决这个问题的。

						在webpack中，配置devtool属性。来控制source maps

					</section>
					<section data-markdown="" style="text-align: justify;font-size: 20px;">
						devtool的值有四种：

| devtool | 配置结果 |
| ------| ----- |
| source-map | 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度； |
| cheap-module-source-map | 在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便；|
| eval-source-map |  使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项；|
| cheap-module-eval-source-map | 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点； |

正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的构建速度的后果就是对打包后的文件的的执行有一定影响。

> 开发环境推荐使用eval-source-map
> 生产环境使用：cheap-module-eval-source-map方法构建速度更快

					</section>
					<section data-markdown="" style="text-align: justify;font-size: 28px;">
						###	构建本地服务器

						想不想让你的浏览器监测你的代码的修改，并自动刷新修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖

```js
	npm install --save-dev webpack-dev-server
```

					</section>
					<section data-markdown="" style="text-align: justify;font-size: 24px;">
					devserver作为webpack配置选项中的一项，具有以下配置选项

| devServer | 功能描述 |
| ------| ----- |
| contentBase |  默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到"public"目录）|
| port |  设置默认监听端口，如果省略，默认为"8080" |
| inline |  设置为true，当源文件改变时会自动刷新页面 |
| colors |  设置为true，使终端输出的文件为彩色的 |
| historyApiFallback |  在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html |

					</section>
					<section data-markdown="" style="text-align: justify;font-size: 28px;">
```js
module.exports = {
  devtool: 'eval-source-map',

  entry:  __dirname + "/app/main.js",
  output: {
    path: __dirname + "/public",
    filename: "bundle.js"
  },

  devServer: {
    contentBase: "./public",//本地服务器所加载的页面所在的目录
    colors: true,//终端中输出结果为彩色
    historyApiFallback: true,//不跳转
    inline: true,//实时刷新
	port: 3000
  } 
}
```

					</section>

				</section>
				<section>
				关于Webpack本文讲述得仍不完全，不过相信你看完后已经进入Webpack的大门，能够更好的探索其它的关于Webpack的知识了。

				</section>
				<section>
					<section data-markdown="">
						###	demo
					</section>
					<section data-markdown="">
						- 准备一个package.json
						- 准备一个webapck.config.json
						- 顺带来一个README.md
						- 自创目录结构
					</section>
					<section>
						<img data-src="img/demo_root.png" />
					</section>
					<section data-markdown="" class="config">
						```js
							var path = require('path');
							var webpack = require("webpack");
							var HtmlWebpackPlugin = require("html-webpack-plugin");
							var OpenBrowserPlugin = require('open-browser-webpack-plugin');

							var ROOT_PATH = path.resolve(__dirname);
							var WEB_PATH = path.resolve(ROOT_PATH, 'src');
							var BUILD_PATH = path.resolve(ROOT_PATH, 'dist');

							module.exports = {
								entry: [
									"babel-polyfill",
									"whatwg-fetch",
									WEB_PATH			
								],
								devServer: {
									hot: true,
									inline: true,
									contentBase: BUILD_PATH,
									port: 3000,
									host: "0.0.0.0",
									publicPath: "/",
									historyApiFallback: true,
									disableHostCheck: true
								},
								output: {
									path: BUILD_PATH,
									publicPath: "/",
									filename: "app.[hash].js"
								},
								devtool: "eval",
								resolve: {
									extensions: ['.js', '.jsx', '.less', '.css', '.png', '.jpg', '.jpeg'],
									alias: {
										"components": path.join(WEB_PATH, '/components/index.js'),
										"assets": path.join(WEB_PATH, '/assets')
									}
								},
								module: {
									rules: [
										{
											test: /\.js$/,
											exclude: /node_modules/,
											loader: "babel-loader",
											options: {
												presets: [
													["es2015", {"modules": false}],
													"stage-0",
													"react"
												],
												plugins: [
													"transform-async-to-generator",
													"transform-decorators-legacy"
												]
											}
										},
										{
											test: /\.less|css$/,
											use: [
												"style-loader",
												"css-loader",
												"less-loader"
											]
										},
										{
											test: /\.(png|jpg|gif|jpeg|svg|eot|woff|ttf|worff2)$/,
											loader: 'file-loader'
										}
									]
								},
								plugins: [
									new webpack.NamedModulesPlugin(),
									new webpack.HotModuleReplacementPlugin(),
									new HtmlWebpackPlugin({ hash: false, template: "./index.html"}),		
									new webpack.ContextReplacementPlugin(/moment[\/\\]locale$/, /nb/),
									new OpenBrowserPlugin({url: 'http://localhost:3000', browser: "Google Chrome"}),

									new webpack.optimize.CommonsChunkPlugin({name: "common", filename: "common.js"}),

								]
							}

						```
					</section>
					<section>
						entry

						<img data-src="img/demo_entry.png" />
					</section>
					<section data-markdown="">
						npm scripts
						```js
							"scripts": {
   								"start": "webpack-dev-server --config webpack.config.js",
								"build": "rimraf ./dist && webpack --config webpack.config.production.js"
							},
						```
					</section>
					<section>
						运行npm start
						<img data-src="img/demo_npmstart.png" />
					</section>
					<section data-markdown="">
						```js
							var path = require('path');
							var webpack = require('webpack');
							var HtmlWebpackPlugin = require('html-webpack-plugin');
							var ExtractTextPlugin = require("extract-text-webpack-plugin");

							var ROOT_PATH = path.resolve(__dirname);
							var WEB_PATH = path.resolve(ROOT_PATH, 'src');
							var BUILD_PATH = path.resolve(ROOT_PATH, 'dist');

							module.exports = {
								entry: {
									vendor: ["react", "react-dom", "react-router"],
									app: ["babel-polyfill", WEB_PATH]
								},
								output: {
									path: BUILD_PATH,
									publicPath: "/",
									filename: "assets/[name].[hash].js",
									chunkFilename: "assets/[name].[chunkhash].js"
								},
								devtool: 'cheap-module-source-map',
								resolve: {
									extensions: ['.js', '.jsx', '.less', '.css', '.png', '.jpg', '.jpeg'],
									alias: {
										"components": path.join(WEB_PATH, '/components/index.js'),
										"assets": path.join(WEB_PATH, '/assets')
									}
								},
								module: {
									rules: [...]	
								},
								plugins: [
									new webpack.DefinePlugin({
										"process.env": {
											NODE_ENV: JSON.stringify("production")
										}
									}),
									new webpack.NamedModulesPlugin(),
									new webpack.optimize.OccurrenceOrderPlugin(true),
									new webpack.optimize.CommonsChunkPlugin({
										name: "vendor",
										minChunks: Infinity
									}),
									new webpack.optimize.UglifyJsPlugin({
										minimize: true,
										compress: {
											warnings: false,
											drop_console: true,
											screw_ie8: true
										},
										output: {
											comments: false
										}
									}),
									new ExtractTextPlugin("assets/styles.css"),
									new HtmlWebpackPlugin({
										hash: false,
										template: "./index.html"
									})
								]
								}
						```
					</section>
					<section>
						运行npm run build
						<img data-src="img/demo_build.png" />
					</section>
					
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					
						

					{
						src: 'plugin/highlight/highlight.js',
					    condition: undefined,
					    async: true,
					    callback: function() { hljs.initHighlightingOnLoad(); }
				    },

						

					
						

					{
						src: 'plugin/markdown/marked.js',
					    condition: function() { return !!document.querySelector( '[data-markdown]' ); },
					    async: false,
					    callback: undefined
				    },

						

					{
						src: 'plugin/markdown/markdown.js',
					    condition: function() { return !!document.querySelector( '[data-markdown]' ); },
					    async: false,
					    callback: undefined
				    },

						

					
						

					{
						src: 'plugin/math/math.js',
					    condition: undefined,
					    async: true,
					    callback: undefined
				    },

						

					
						

					{
						src: 'plugin/zoom-js/zoom.js',
					    condition: undefined,
					    async: true,
					    callback: undefined
				    },

						

					
				]
			});

		</script>

	</body>
</html>
